#' Create an Angled Terrain-Following Flight Path
#'
#' @description
#' Generates a flight path where the sensor maintains constant distance from the terrain
#' at a specified angle, while the aircraft's actual height above ground varies.
#'
#' @details
#' Key characteristics:
#' \itemize{
#'   \item Maintains constant sensor-to-terrain distance at specified angle (not constant AGL)
#'   \item Adjusts both horizontal position and aircraft altitude based on terrain
#'   \item Aircraft height above ground will vary to maintain sensor geometry
#'   \item For constant AGL height, use \code{\link{create_sagl_flight_path}} instead
#' }
#'
#' The path is generated by:
#' 1. Calculating horizontal and vertical offsets based on sensor angle
#' 2. Shifting sample points according to these offsets
#' 3. Verifying elevations at shifted positions
#' 4. Constructing the final flight trajectory
#'
#' @param deploy_coords Numeric vector of length 2 containing deployment coordinates (x,y)
#'        in the specified CRS (default UTM Zone 32N)
#' @param land_coords Numeric vector of length 2 containing landing coordinates (x,y)
#'        in the same CRS as deployment coordinates
#' @param dsm_path Character string specifying path to Digital Surface Model (DSM) raster file.
#'        Must cover the entire flight path including shifted positions.
#' @param N Integer specifying number of sample points along the path (default = 100).
#' @param H Numeric value for desired sensor height above terrain in meters (default = 10).
#'        This is the distance from terrain to sensor along the angle, not vertical AGL.
#' @param sensorangle Numeric value for sensor angle in degrees from vertical (0 = nadir,
#'        90 = horizontal). Must be between 0 and 90 (exclusive).
#'
#' @section Important Note:
#' This function maintains constant sensor-to-terrain distance at an angle, not constant
#' aircraft altitude above ground. The actual aircraft AGL will vary with terrain. For missions
#' requiring constant AGL height, use \code{\link{create_sagl_flight_path}} instead.
#'
#' @examples
#' \dontrun{
#' # 45° angled sensor maintaining 10m slant range
#' path <- create_angled_flight_path(
#'   deploy_coords = c(580000, 5510000),
#'   land_coords = c(580500, 5510500),
#'   dsm_path = "path/to/dsm.tif",
#'   sensorangle = 45,
#'   H = 10
#' )
#'
#' # Compare with constant AGL path:
#' sagl_path <- create_sagl_flight_path(
#'   deploy_coords = c(580000, 5510000),
#'   land_coords = c(580500, 5510500),
#'   dsm_path = "path/to/dsm.tif",
#'   H = 10
#' )
#' }
create_angled_flight_path <- function(deploy_coords, land_coords, dsm_path, N = 100, H = 10,
                                      sensorangle = 0, crs_proj = "EPSG:32632", minDist = 1,
                                      speed_p = 5, calfig_params = NULL) {

  # Validate inputs
  validate_inputs(deploy_coords, land_coords, dsm_path, N, H)
  stopifnot(is.numeric(sensorangle), sensorangle >= 0, sensorangle < 90)

  # Load DSM and create original line
  DSM <- load_dsm(dsm_path, crs_proj)

  # Create sf points and line
  points_and_line <- create_points_and_line(deploy_coords, land_coords, crs_proj)
  line <- points_and_line$line

  # Create polygon from the raster's extent
  extent_poly <- terra::as.polygons(ext(DSM), crs = crs_proj)

  # Reproject the polygon to WGS84
  extent_poly_wgs84 <- project(extent_poly, "EPSG:4326") %>% sf::st_as_sf()

  # Double check that the line is included within the DSM pn the given projection
  if (!sf::st_intersects(sf::st_as_sf(line), sf::st_as_sf(extent_poly), sparse = FALSE)) {
    stop("The flight path line is not within the DSM extent in the specified projection.")
  }

  # Sample points along line and extract elevations
  sampled_pts <- sample_points(line, N)

  # Make sure that the sampled poijnts have at least minDist between them
  sampled_pts <- sf::st_segmentize(sampled_pts, minDist)

  # Extract elevations from DSM
  sampled_pts <- extract_elevations(sampled_pts, DSM)

  # Remove any points with NA elevations
  valid_points <- !is.na(sampled_pts$Elevation)
  sampled_pts <- sampled_pts[valid_points, ]
  if (nrow(sampled_pts) < 2) stop("Not enough valid points after removing NA elevations")

  # Calculate distances from first point
  first_point <- sf::st_geometry(sampled_pts)[1]
  distances <- sf::st_distance(sf::st_geometry(sampled_pts), first_point)
  sampled_pts$dist_to_first <- as.numeric(distances)

  # Convert angle to radians
  angle_rad <- sensorangle * pi / 180

  # Calculate offset components
  vertical_component <- H * cos(angle_rad)
  horizontal_component <- H * sin(angle_rad)

  # Apply shifts
  sampled_pts$ShiftDistance <- sampled_pts$dist_to_first - horizontal_component
  sampled_pts$ShiftElevation <- sampled_pts$Elevation + vertical_component

  # Reconstruct coordinates along original line direction
  line_vec <- land_coords - deploy_coords
  line_length <- sqrt(sum(line_vec^2))
  unit_vec <- line_vec / line_length

  # Calculate new XY coordinates based on shifted distances
  new_coords <- t(sapply(sampled_pts$ShiftDistance, function(d) {
    deploy_coords + unit_vec * d
  }))

  # Create final data frame
  final_df <- data.frame(
    X = new_coords[,1],
    Y = new_coords[,2],
    Z = sampled_pts$ShiftElevation
  )

  # Create spatial objects (Line)
  offset_line <- sf::st_linestring(as.matrix(final_df[, c("X", "Y")])) %>%
    sf::st_sfc(crs = crs_proj)

  # Create an area around the offset_line to export in the future as KML and project to wgs84
  AOI_KML <- sf::st_simplify(offset_line, dTolerance = 0.01) %>%
    sf::st_buffer(dist = 5, endCapStyle = "SQUARE") %>% sf::st_transform(4326)

  # Create spatial objects (Points)
  offset_points <- sf::st_as_sf(final_df, coords = c("X", "Y"), crs = crs_proj)

  # Extract the DMS height at the new shifted location
  final_df$ShiftedH <- extract_elevations(offset_points, DSM)$Elevation

  # Check for NAs on the ShiftedH
  if (any(is.na(final_df$ShiftedH))) {
    warning("Some points have NA elevations after shifting. Check DSM coverage.")
    final_df <- final_df[!is.na(final_df$ShiftedH), ]
    offset_points <- offset_points[!is.na(final_df$ShiftedH), ]
  }

  # Add the Speed field
  final_df$Speed <- speed_p

  # Add the type field
  final_df$Type <- "Trajectory"

  # Merge final coordinates from trajectory and from calibration figures
  if (!is.null(calfig_params) && length(calfig_params) > 0) {

    # Get AMSL heith for starting point
    startH <- terra::extract(DSM, matrix(c(calfig_params[["Lat"]], calfig_params[["Lon"]]), ncol = 2))

    # Add startH to the list
    calfig_params$startH <- startH[,1]

    # Make calibration figures (use speed_c to append)
    calfig <- do.call(make_calfig, calfig_params)

    # Convert calfig matrix to dataframe
    calfig_df <- as.data.frame(calfig)

    # Add 'type' column filled with "Cal"
    calfig_df$Type <- "Cal"

    # Append calibration figures at the beginning and at the end of final_coords
    final_df <- dplyr::bind_rows(calfig_df, final_df, calfig_df)

    # Remove consecutive duplicates while preserving order
    final_df <- final_df[c(TRUE, !(final_df$X[-1] == final_df$X[-nrow(final_df)] &
                                     final_df$Y[-1] == final_df$Y[-nrow(final_df)] &
                                     final_df$Z[-1] == final_df$Z[-nrow(final_df)])), ]

  }

  message("Flight parameter summary")
  # Total number of points with warning if >99
  if (nrow(final_df) > 99) {
    cat(sprintf("\033[31m❗️  Total points in final flight path: %d (exceeds DJI limit of 99), please reduce SamplePoints parameter.\033[0m\n", nrow(final_df)))
  } else {
    cat(sprintf("\033[32m✅ Total points in final flight path: %d\033[0m\n", nrow(final_df)))
  }

  # Calibration figure check
  if (any(final_df$Type == "Cal")) {
    cat("\033[32m✅ Two calibration figures were included in flight path.\033[0m\n")
  } else {
    cat("\033[33m⚠️ Calibration figures were not included in flight path — check `calfig_params()`.\033[0m\n")
  }
  message("\n")

  # return parameters
  list(
    deploy_coords = deploy_coords,
    land_coords = land_coords,
    sampled_points = sampled_pts,
    terrain_line = line,
    offset_points = offset_points,
    offset_line = offset_line,
    final_coords = final_df,
    dsm_extent = extent_poly_wgs84,
    aoi_kml = AOI_KML,
    parameters = list(N = N, H = H, angle = sensorangle, crs = crs_proj)
  )
}

# Helper functions (not exported)
validate_inputs <- function(deploy_coords, land_coords, dsm_path, N, H) {
  stopifnot(
    length(deploy_coords) == 2,
    length(land_coords) == 2,
    is.numeric(N), N > 0,
    is.numeric(H), H >= 0,
    file.exists(dsm_path))
}

load_dsm <- function(dsm_path, crs_proj) {
  DSM <- terra::rast(dsm_path)
  terra::project(DSM, crs_proj)
}

create_points_and_line <- function(deploy_coords, land_coords, crs_proj) {
  deploy_sf <- sf::st_sfc(sf::st_point(deploy_coords), crs = crs_proj)
  land_sf <- sf::st_sfc(sf::st_point(land_coords), crs = crs_proj)
  line <- sf::st_sfc(
    sf::st_linestring(rbind(
      sf::st_coordinates(deploy_sf),
      sf::st_coordinates(land_sf))),
    crs = crs_proj)

  list(deploy_sf = deploy_sf, land_sf = land_sf, line = line)
}

sample_points <- function(line, N) {
  sf::st_line_sample(line, n = N, type = "regular") %>%
    sf::st_cast("POINT") %>%
    sf::st_as_sf()
}

extract_elevations <- function(sampled_pts, DSM) {
  sampled_pts$Elevation <- terra::extract(DSM, terra::vect(sampled_pts))[, 2]
  sampled_pts
}

create_sampled_df <- function(sampled_pts, deploy_sf) {
  sampled_df <- sampled_pts
  sampled_df$distance <- as.numeric(sf::st_distance(deploy_sf, sampled_pts)[1, ])
  sampled_df
}
